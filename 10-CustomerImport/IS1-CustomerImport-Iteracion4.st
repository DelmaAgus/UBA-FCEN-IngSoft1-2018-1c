Object subclass: #ClassMapping	instanceVariableNames: 'mappedClass mappings tableName'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-PersistanceModel'!!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:43'!unmap: aRecord into: unMappedObject using: aDataBaseSession	mappings do: [ :aMapping | aMapping unmap: aRecord into: unMappedObject using: aDataBaseSession ]! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:43'!unmapIdOf: aRecord into: unMappedObject	unMappedObject instVarNamed: #id put: (aRecord at: #id)! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	mappings do: [ :aMapping | aMapping mapOneToManyRelationshipsOf: anObject using: aDataBaseSession ]! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapEmbededOf: anObject into: record	mappings do: [ :aMapping | aMapping embeded: anObject into: record ]! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapIdOf: anObject into: record using: aDataBaseSession	| newId |	newId := aDataBaseSession newIdFor: anObject.	anObject instVarNamed: #id put: newId.	record at: #id put: newId! !!ClassMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:25'!initializeFor: aClass into: aTableName mappingAll: aCollectionOfMappings	mappedClass := aClass.	tableName := aTableName.	mappings := aCollectionOfMappings ! !!ClassMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 00:42'!unmap: aRecord using: aDataBaseSession	| unMappedObject |	unMappedObject := mappedClass basicNew.	self unmapIdOf: aRecord into: unMappedObject.	self unmap: aRecord into: unMappedObject using: aDataBaseSession.	^ unMappedObject! !!ClassMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 00:40'!map: anObject using: aDataBaseSession	| record |	self toDo: 'se puede optimizar usando array para registros y guardando definicion de tabla una vez'.	record := Dictionary new.		self mapIdOf: anObject into: record using: aDataBaseSession.	self mapEmbededOf: anObject into: record.	"agrego aca el registro y no luego de mapear el id para que lo agrege completo. Lo agrego antes de mapear las rel one to many 	porque si usuara una db de verdad habria foreign key constrain"	aDataBaseSession add: record on: self tableName.	self mapOneToManyRelationshipsOf: anObject using: aDataBaseSession! !!ClassMapping methodsFor: 'table' stamp: 'HernanWilkinson 10/31/2016 23:25'!tableName		^tableName ! !!ClassMapping methodsFor: 'testing' stamp: 'HernanWilkinson 10/31/2016 23:02'!isFor: aClass	^mappedClass = aClass! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ClassMapping class	instanceVariableNames: ''!!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:24'!for: aClass into: aTableName mappingAll: aCollectionOfMappings	self assertValidTableName: aTableName.	self assertHasIdInstanceVariable: aClass.	self assertValidMappings: aCollectionOfMappings for: aClass.		^self new initializeFor: aClass into: aTableName mappingAll: aCollectionOfMappings		! !!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 00:44'!defaultTableNameFor: aClass		^aClass name asString! !!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:23'!withDefaultTableNameFor: aClass mappingAll: aCollectionOfMappings	^self for: aClass into: (self defaultTableNameFor: aClass) mappingAll: aCollectionOfMappings		! !!ClassMapping class methodsFor: 'assertions' stamp: 'AD 6/30/2018 22:00'!assertHasIdInstanceVariable: aClass 		((aClass hasInstVarNamed: #id) or: [aClass superclass hasInstVarNamed: #id ]) ifFalse: [ self error: ('<1s> has no id instance variable' expandMacrosWith: aClass name) ]! !!ClassMapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 19:26'!assertValidMappings: aCollectionOfMappings for: aClass 	self toDo: 'Lo mejor seria recolectar todos los erroes de mapeo y no parar en el primero'.	aCollectionOfMappings do: [ :aMapping | aMapping assertIsValidFor: aClass ]	! !!ClassMapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 23:41'!assertValidTableName: aTableName	aTableName trimBoth isEmpty ifTrue: [ self error: 'Table name can not be empty' ]! !Object subclass: #DataBaseSession	instanceVariableNames: 'configuration tables id cache'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-PersistanceModel'!!DataBaseSession methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 22:55'!initializeFor: aConfiguration	configuration := aConfiguration.	id := 0.	tables := nil.	cache := nil.! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:00'!signalRelationAlreadyExistBetween: anOwner and: aRelated 	self error: ('Relation between id <1s> of type <2s> and id <3s> of type <4s> already exist'		expandMacrosWith: (self idOf: anOwner) printString		with: anOwner class name		with: (self idOf: aRelated) printString		with: aRelated class name)! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:10'!relatedIdsOwnedBy: anOwner forType: aRelatedClass	| relatedIds table |	table := self relationTableFor: anOwner class relatedTo: aRelatedClass.	relatedIds := self relatedIdOwnedBy: anOwner on: table.		^ relatedIds! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:03'!addRelated: aRelated ownedBy: anOwner	| relatedIds relatedId |	relatedIds := self relatedIdsOwnedBy: anOwner forType: aRelated class.	relatedId := aRelated instVarNamed: #id.	self assertRelationOwnedBy: anOwner isUniqueFor: aRelated identifiedAs: relatedId in: relatedIds.		relatedIds add: relatedId! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:06'!relatedIdOwnedBy: anOwner on: table	^ table at: (self idOf: anOwner) ifAbsentPut: [ Set new ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:03'!add: aRecord on: aTableName	| table existingRecord |	table := self tableNamed: aTableName.	existingRecord := table at: (self recordId: aRecord) ifAbsentPut: [ aRecord ].	existingRecord == aRecord ifFalse: [ self error: 'Duplicated primary key' ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:27'!addToCache: anObject 	cache at: (self idOf: anObject) put: anObject ! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:05'!assertRelationOwnedBy: anOwner isUniqueFor: aRelated identifiedAs: relatedId in: relatedIds	(relatedIds includes: relatedId) ifTrue: [ self signalRelationAlreadyExistBetween: anOwner and: aRelated ]! !!DataBaseSession methodsFor: 'selecting - private' stamp: 'HernanWilkinson 11/1/2016 01:28'!addInto: selected theOnesThatHold: aCondition unmapping: record with: mapper	| recordId aClassInstance |	recordId := self recordId: record.	aClassInstance := cache at: recordId ifAbsent: [ mapper unmap: record using: self ].	(aCondition value: aClassInstance) ifTrue: [ 		self addToCache: aClassInstance.		selected add: aClassInstance ].		^ selected! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:57'!beginTransaction	self assertIsOpen.	self assertNotInTransasction.		cache := WeakKeyDictionary new.	! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:55'!assertInTransaction		cache isNil ifTrue: [ self error: 'There is no transaction currently' ]! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:55'!assertNotInTransasction		cache notNil ifTrue: [ self error: 'There is an open transaction already' ]! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:57'!commit		self assertInTransaction.		cache := nil! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 01:12'!relationTableNameOwnedBy: anOwnerClass relatedTo: aRelatedClass	| ownerClassMapper relatedClassMapper |		ownerClassMapper := self mapperFor: anOwnerClass.	relatedClassMapper := self mapperFor: aRelatedClass.		^ownerClassMapper tableName,'_', relatedClassMapper tableName asPlural.! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 01:12'!relationTableFor: anOwnerClass relatedTo: aRelatedClass	| relationTableName table |	relationTableName := self relationTableNameOwnedBy: anOwnerClass relatedTo: aRelatedClass.	table := self tableNamed: relationTableName.		^ table! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 00:48'!tableNamed: aTableName	^ tables at: aTableName ifAbsentPut: [ Dictionary new ]! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:16'!unmapRecordIdentifiedAs: anId ofType: aClass	| record table mapper |	mapper := self mapperFor: aClass.	table := self tableNamed: mapper tableName.	record := table at: id ifAbsent: [ self error: ('Object identified as <1s> does not exist' expandMacrosWith: anId printString) ].		^ mapper unmap: record using: self! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:14'!mapperFor: aClass	self toDo: 'se puede mejorar performanco usando un dictionary'.	^configuration		detect: [ :aClassMapper | aClassMapper isFor: aClass ] 		ifNone: [ self error: ('There is no mapper for <1s>' expandMacrosWith: aClass name) ]! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:15'!relatedOfType: aRelatedClass for: anOwner	| table relatedIds |		table := self relationTableFor: anOwner class relatedTo: aRelatedClass.	relatedIds := table at: (self idOf: anOwner) ifAbsent: [ ^#() ].		^relatedIds collect: [ :aRelatedId | self objectIdentifiedAs: aRelatedId ofType: aRelatedClass ]		! !!DataBaseSession methodsFor: 'persistance' stamp: 'HernanWilkinson 11/1/2016 01:28'!persist: anObject	| mapper |		self assertInTransaction.	self delay.		mapper := self mapperFor: anObject class.	mapper map: anObject using: self.		self addToCache: anObject ! !!DataBaseSession methodsFor: 'persistence - private' stamp: 'HernanWilkinson 10/28/2016 16:35'!defineIdOf: anObject	anObject instVarNamed: 'id' put: (self newIdFor: anObject).! !!DataBaseSession methodsFor: 'persistence - private' stamp: 'HernanWilkinson 10/28/2016 16:41'!delay	(Delay forMilliseconds: 100) wait! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 10/28/2016 16:35'!newIdFor: anObject	id := id + 1.	^id! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 11/1/2016 01:00'!idOf: anObject	^anObject instVarNamed: #id! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 11/1/2016 01:04'!recordId: aRecord	^aRecord at: #id! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 11/1/2016 01:26'!select: aCondition ofType: aClass	| mapper table |	self assertInTransaction.	self delay.		mapper := self mapperFor: aClass.	table := tables at: mapper tableName ifAbsent: [ ^ #() ].		^ table inject: OrderedCollection new into: [ :selected :record | self addInto: selected theOnesThatHold: aCondition unmapping: record with: mapper ]! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 10/31/2016 22:17'!selectAllOfType: aClass 		^self select: [ :anObject | true ] ofType: aClass! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 11/1/2016 01:15'!objectIdentifiedAs: anId ofType: aClass	self assertInTransaction.	self delay.		^ cache at: anId ifAbsentPut: [ self unmapRecordIdentifiedAs: anId ofType: aClass ]! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:37'!assertIsClose		tables isNil ifFalse: [ self error: 'Session must be close' ]! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 22:14'!close	self assertIsOpen.		tables := nil! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:36'!assertIsOpen		tables isNil ifTrue: [ self error: 'Session must be open to colaborate with it' ]! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:36'!open	self assertIsClose.		tables := Dictionary new.	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DataBaseSession class	instanceVariableNames: ''!!DataBaseSession class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/28/2016 13:07'!for: aConfiguration	^self new initializeFor: aConfiguration! !Object subclass: #Mapping	instanceVariableNames: 'instanceVariableName'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-PersistanceModel'!!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!unmap: aRecord into: anObject using: aDataBaseSession	self subclassResponsibility! !!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!embeded: anObject into: aRecord	self subclassResponsibility! !!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	self subclassResponsibility! !!Mapping methodsFor: 'assertions' stamp: 'AD 6/30/2018 21:57'!assertIsValidFor: aClass 	((aClass hasInstVarNamed: instanceVariableName) or: [aClass superclass hasInstVarNamed: instanceVariableName]) ifFalse: [ 		self error: ('Invalid mapping for <1s> in class <2s>' expandMacrosWith: instanceVariableName with: aClass name) ] ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Mapping class	instanceVariableNames: ''!!Mapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 23:41'!assertValidFieldName: aFieldName	aFieldName trimBoth isEmpty ifTrue: [ self error: 'Field name can not be empty' ]! !!Mapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 01:32'!defaultFieldNameFor: anInstanceVariableName	^anInstanceVariableName asString! !Mapping subclass: #EmbededMapping	instanceVariableNames: 'fieldName'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-PersistanceModel'!!EmbededMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:30'!initializeFor: anInstanceVariableName into: aFieldName	instanceVariableName := anInstanceVariableName.	fieldName := aFieldName ! !!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:31'!unmap: aRecord into: anObject using: aDataBaseSession 	anObject instVarNamed: instanceVariableName put: (aRecord at: fieldName)! !!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:31'!embeded: anObject into: aRecord	aRecord at: fieldName put: (anObject instVarNamed: instanceVariableName) ! !!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 21:23'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession 		! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EmbededMapping class	instanceVariableNames: ''!!EmbededMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:30'!for: anInstanceVariableName into: aFieldName	^self new initializeFor: anInstanceVariableName into: aFieldName ! !!EmbededMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:29'!withDefaultFieldNameFor: anInstanceVariableName	^self for: anInstanceVariableName into: (self defaultFieldNameFor: anInstanceVariableName)! !Mapping subclass: #OneToManyMapping	instanceVariableNames: 'relatedType fieldName'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-PersistanceModel'!!OneToManyMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:34'!initializeFor: anInstanceVariableName into: aFieldName ofType: aClass	instanceVariableName := anInstanceVariableName.	fieldName := aFieldName.	relatedType := aClass ! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:37'!unmap: aRecord into: anObject using: aDataBaseSession	| newCollection related |	related := aDataBaseSession relatedOfType: relatedType for: anObject.	newCollection := self createRelationCollectionOn: aDataBaseSession ownedBy: anObject.	newCollection addAllNotPersisting: related.	anObject instVarNamed: instanceVariableName put: newCollection! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:35'!createRelationCollectionOn: aDataBaseSession ownedBy: anObject	^ OneToManySet on: aDataBaseSession ownedBy: anObject! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 21:16'!embeded: anObject into: aRecord	! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:37'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	| oldCollection newCollection |	newCollection := self createRelationCollectionOn: aDataBaseSession ownedBy: anObject.	oldCollection := anObject instVarNamed: instanceVariableName.		newCollection addAll: oldCollection.	anObject instVarNamed: instanceVariableName put: newCollection! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OneToManyMapping class	instanceVariableNames: ''!!OneToManyMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:32'!withDefaultFieldNameFor: anInstanceVariableName ofType: aClass	^self for: anInstanceVariableName into: (self defaultFieldNameFor: anInstanceVariableName) ofType: aClass! !!OneToManyMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:40'!for: anInstanceVariableName into: aFieldName ofType: aClass	self assertValidFieldName: aFieldName.		^self new initializeFor: anInstanceVariableName into: aFieldName ofType: aClass! !Set subclass: #OneToManySet	instanceVariableNames: 'session owner'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-PersistanceModel'!!OneToManySet methodsFor: 'removing' stamp: 'HernanWilkinson 10/31/2016 21:35'!remove: anObject ifAbsent: anAbsentBlock	self shouldBeImplemented ! !!OneToManySet methodsFor: 'initialization' stamp: 'HernanWilkinson 11/1/2016 00:11'!initializeOn: aDataBaseSession ownedBy: anOwner		session := aDataBaseSession.	owner := anOwner ! !!OneToManySet methodsFor: 'adding' stamp: 'HernanWilkinson 11/1/2016 00:11'!add: anObject	session persist: anObject.	session addRelated: anObject ownedBy: owner.		super add: anObject.! !!OneToManySet methodsFor: 'adding' stamp: 'HernanWilkinson 11/1/2016 00:03'!addAllNotPersisting: aCollection 		^aCollection do: [ :anObjectToAdd | super add: anObjectToAdd ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OneToManySet class	instanceVariableNames: ''!!OneToManySet class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 00:11'!on: aDataBaseSession ownedBy: anOwner		^self new initializeOn: aDataBaseSession ownedBy: anOwner ! !Object subclass: #Address	instanceVariableNames: 'id streetName streetNumber town zipCode province'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!Address methodsFor: 'zip code' stamp: 'HernanWilkinson 10/28/2016 16:13'!zipCode	^zipCode! !!Address methodsFor: 'zip code' stamp: 'HernanWilkinson 10/28/2016 16:08'!zipCode: aZipCode 	zipCode := aZipCode! !!Address methodsFor: 'zip code' stamp: 'HernanWilkinson 11/1/2016 10:06'!isAt: aStreetName	^streetName = aStreetName ! !!Address methodsFor: 'town' stamp: 'HernanWilkinson 10/28/2016 16:07'!town: aTown 	town := aTown! !!Address methodsFor: 'town' stamp: 'HernanWilkinson 10/28/2016 16:12'!town	^town! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 13:27'!streetNumber: aStreetNumber 	streetNumber := aStreetNumber ! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 16:12'!streetNumber	^streetNumber ! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 13:27'!streetName: aStreetName 	streetName := aStreetName ! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 16:12'!streetName	^streetName ! !!Address methodsFor: 'province' stamp: 'HernanWilkinson 10/28/2016 16:11'!province	^province! !!Address methodsFor: 'province' stamp: 'HernanWilkinson 10/28/2016 16:08'!province: aProvince 	province := aProvince	! !TestCase subclass: #CustomerImportTest	instanceVariableNames: 'importer testDataFactory customerSystem'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!CustomerImportTest methodsFor: 'importing' stamp: 'AgustinDelger 6/30/2018 16:28'!customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber	| customer |		customer := customerSystem		customerIdentifiedAs: anIdentifycationType		numbered: anIdentificationNumber		ifNone: [ self fail ].			^ customer! !!CustomerImportTest methodsFor: 'importing' stamp: 'AD 6/26/2018 10:03'!shouldImportingCustomersFrom: testData raiseErrorDo: errorBlock	| customerImporter |	customerImporter := CustomerImporter from: testData on: customerSystem.	self		should: [ customerImporter import ]		raise: Error		withExceptionDo: [ :anError | errorBlock value: anError ]! !!CustomerImportTest methodsFor: 'asserting' stamp: 'AD 6/25/2018 22:12'!assertImportedCustomersSizeIs: anAmountOfCustomers	self		assert: customerSystem amountOfCustomersImported		equals: anAmountOfCustomers! !!CustomerImportTest methodsFor: 'asserting' stamp: 'HernanWilkinson 11/1/2016 11:00'!assert: customer hasAddressAt: streetName number: streetNumber in: town zipCode: zipCode province: province	| address |		address := customer addressAt: streetName ifNone: [ self fail ].	self assert: address streetName equals: streetName.	self assert: address streetNumber equals: streetNumber.	self assert: address town equals: town.	self assert: address zipCode equals: zipCode.	self assert: address province equals: province.	! !!CustomerImportTest methodsFor: 'asserting' stamp: 'AD 6/23/2018 17:09'!assertPepeSanchezWasImportedWithoutAddressesCorrectly	| customer idType idNumber |	idType := 'D'.	idNumber := '22333444'.	customer := self customerIdentifiedAs: idType numbered: idNumber.		self assert: customer isNamed: 'Pepe' lastName: 'Sanchez' identfiedAs: idType withNumber: idNumber andNumberOfAddresses: 0.! !!CustomerImportTest methodsFor: 'asserting' stamp: 'HernanWilkinson 11/1/2016 15:14'!assertJuanPerezWasImportedCorrectly		| customer idType idNumber |		idType := 'C'.	idNumber := '23-25666777-9'.	customer := self customerIdentifiedAs: idType numbered: idNumber.		self assert: customer isNamed: 'Juan' lastName: 'Perez' identfiedAs: idType withNumber: idNumber andNumberOfAddresses: 1.	self assert: customer hasAddressAt: 'Alem' number: 1122 in: 'CABA' zipCode: 1001 province: 'CABA'.	! !!CustomerImportTest methodsFor: 'asserting' stamp: 'AD 6/23/2018 16:34'!assertNoAddressesWereImported	self assert: (session selectAllOfType: Address) isEmpty.! !!CustomerImportTest methodsFor: 'asserting' stamp: 'AgustinDelger 6/25/2018 09:57'!assertNoCustomersWereImported	self assertImportedCustomersSizeIs: 0.! !!CustomerImportTest methodsFor: 'asserting' stamp: 'HernanWilkinson 11/1/2016 15:16'!assertPepeSanchezWasImportedCorrectly	| customer idType idNumber |	idType := 'D'.	idNumber := '22333444'.	customer := self customerIdentifiedAs: idType numbered: idNumber.		self assert: customer isNamed: 'Pepe' lastName: 'Sanchez' identfiedAs: idType withNumber: idNumber andNumberOfAddresses: 2.	self assert: customer hasAddressAt: 'San Martin' number: 3322 in: 'Olivos' zipCode: 1636 province: 'BsAs'.	self assert: customer hasAddressAt: 'Maipu' number: 888 in: 'Florida' zipCode: 1122 province: 'Buenos Aires'! !!CustomerImportTest methodsFor: 'asserting' stamp: 'HernanWilkinson 11/1/2016 10:56'!assert: customer isNamed: firstName lastName: lastName identfiedAs: idType withNumber: idNumber andNumberOfAddresses: addressesSize	self assert: customer firstName equals: firstName.	self assert: customer lastName equals: lastName.	self assert: customer identificationType equals: idType.	self assert: customer identificationNumber equals: idNumber.	self assert: customer numberOfAddresses equals: addressesSize .! !!CustomerImportTest methodsFor: 'testing - customer' stamp: 'AgustinDelger 6/25/2018 14:27'!testCanNotImportCustomerRecordWithTooManyFields	self		shouldImportingCustomersFrom: testDataFactory customerRecordWithTooManyFieldsTestData		raiseErrorDo: [ :anError | 			self				assert: anError messageText				equals: CustomerImporter invalidAmountOfFieldsInCustomerRecordErrorMessage.			self assertNoCustomersWereImported ]! !!CustomerImportTest methodsFor: 'testing - customer' stamp: 'AgustinDelger 6/25/2018 14:27'!testCanNotImportCustomerRecordsWithTooFewFields	self		shouldImportingCustomersFrom: testDataFactory customerRecordWithTooFewFieldsTestData		raiseErrorDo: [ :anError | 			self				assert: anError messageText				equals: CustomerImporter invalidAmountOfFieldsInCustomerRecordErrorMessage.			self assertNoCustomersWereImported ]! !!CustomerImportTest methodsFor: 'testing - customer' stamp: 'AgustinDelger 6/25/2018 14:27'!testCanNotImportCustomerRecordWithExtraCommas	self		shouldImportingCustomersFrom: testDataFactory customerRecordWithExtraCommaTestData		raiseErrorDo: [ :anError | 			self				assert: anError messageText				equals: CustomerImporter invalidAmountOfFieldsInCustomerRecordErrorMessage.			self assertNoCustomersWereImported ]! !!CustomerImportTest methodsFor: 'setup-teardown' stamp: 'AD 6/26/2018 09:22'!setUp	testDataFactory := CustomersTestDataFactory new.		customerSystem := Environment current createCustomerSystem.	customerSystem start.! !!CustomerImportTest methodsFor: 'setup-teardown' stamp: 'AD 6/26/2018 09:42'!tearDown	customerSystem stop.! !!CustomerImportTest methodsFor: 'testing - address' stamp: 'AgustinDelger 6/25/2018 14:28'!testCanNotImportAddressRecordWithTooFewFields	self		shouldImportingCustomersFrom: testDataFactory addressRecordWithTooFewFieldsTestData		raiseErrorDo: [ :anError | 			self				assert: anError messageText				equals: CustomerImporter invalidAmountOfFieldsInAddressRecordErrorMessage.			self assertPepeSanchezWasImportedWithoutAddressesCorrectly.			self assertImportedCustomersSizeIs: 1 ]! !!CustomerImportTest methodsFor: 'testing - address' stamp: 'AgustinDelger 6/25/2018 14:28'!testCanNotImportAddressRecordWithTooManyFields	self		shouldImportingCustomersFrom: testDataFactory addressRecordWithTooManyFieldsTestData		raiseErrorDo: [ :anError | 			self				assert: anError messageText				equals: CustomerImporter invalidAmountOfFieldsInAddressRecordErrorMessage.			self assertPepeSanchezWasImportedWithoutAddressesCorrectly.			self assertImportedCustomersSizeIs: 1 ]! !!CustomerImportTest methodsFor: 'testing - address' stamp: 'AgustinDelger 6/25/2018 14:28'!testCanNotImportAddressRecordWithExtraCommas	self		shouldImportingCustomersFrom: testDataFactory addressRecordWithExtraCommaTestData 		raiseErrorDo: [ :anError | 			self				assert: anError messageText				equals: CustomerImporter invalidAmountOfFieldsInAddressRecordErrorMessage.			self assertImportedCustomersSizeIs: 1.			self assertPepeSanchezWasImportedWithoutAddressesCorrectly.]! !!CustomerImportTest methodsFor: 'testing - general' stamp: 'AD 6/26/2018 10:03'!testCustomerImporterImportsCorrectlyValidInputData	| customerImporter |	customerImporter := CustomerImporter		from: testDataFactory validTestData		on: customerSystem.	customerImporter import.	self assertImportedCustomersSizeIs: 2.	self assertPepeSanchezWasImportedCorrectly.	self assertJuanPerezWasImportedCorrectly! !!CustomerImportTest methodsFor: 'testing - general' stamp: 'AgustinDelger 6/25/2018 14:32'!testCantImportAddressRecordWithoutImportingCustomerRecordFirst	self		shouldImportingCustomersFrom: testDataFactory addressRecordFirstTestData		raiseErrorDo: [ :anError | 			self				assert: anError messageText				equals: CustomerImporter addressRecordWithoutCustomerErrorMessage.			self assertNoCustomersWereImported ]! !!CustomerImportTest methodsFor: 'testing - general' stamp: 'AgustinDelger 6/25/2018 14:27'!testCanNotImportAnEmptyRecord	self		shouldImportingCustomersFrom: testDataFactory emptyRecordTestData		raiseErrorDo: [ :anError | 			self				assert: anError messageText				equals: CustomerImporter emptyRecordErrorMessage.			self assertPepeSanchezWasImportedWithoutAddressesCorrectly.			self assertImportedCustomersSizeIs: 1 ]! !!CustomerImportTest methodsFor: 'testing - general' stamp: 'AgustinDelger 6/25/2018 14:27'!testCantImportRecordWithAnInvalidType	self		shouldImportingCustomersFrom: testDataFactory invalidRecordTypeTestData		raiseErrorDo: [ :anError | 			self				assert: anError messageText				equals: CustomerImporter invalidRecordTypeErrorMessage.			self assertNoCustomersWereImported ]! !Object subclass: #CustomerImporter	instanceVariableNames: 'inputStream record line newCustomer customerSystem'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!CustomerImporter methodsFor: 'initialization' stamp: 'AD 6/26/2018 10:37'!initializeFrom: anInputStream on: aCustomerSystem 	inputStream := anInputStream.	customerSystem := aCustomerSystem.! !!CustomerImporter methodsFor: 'assertions' stamp: 'AgustinDelger 6/27/2018 12:41'!signalRecordHasInvalidType	self error: self class invalidRecordTypeErrorMessage.! !!CustomerImporter methodsFor: 'assertions' stamp: 'AgustinDelger 6/27/2018 12:38'!assertRecordIsNotEmpty	record isEmpty ifTrue:[self error: self class emptyRecordErrorMessage].! !!CustomerImporter methodsFor: 'assertions' stamp: 'AgustinDelger 6/25/2018 11:32'!assertRecordHasCorrectAmountOfFieldsForAddress	(self numberOfFieldsInRecordIs: self amountOfFieldsInAddressRecord)		ifFalse:[self error: self class invalidAmountOfFieldsInAddressRecordErrorMessage].! !!CustomerImporter methodsFor: 'assertions' stamp: 'AgustinDelger 6/25/2018 11:32'!assertRecordHasCorrectAmountOfFieldsForCustomer	(self numberOfFieldsInRecordIs: self amountOfFieldsInCustomerRecord)		ifFalse:[self error: self class invalidAmountOfFieldsInCustomerRecordErrorMessage].! !!CustomerImporter methodsFor: 'assertions' stamp: 'AgustinDelger 6/25/2018 14:46'!assertACustomerHasBeenImported	newCustomer ifNil: [self error: self class addressRecordWithoutCustomerErrorMessage ]! !!CustomerImporter methodsFor: 'importing' stamp: 'AD 6/26/2018 10:00'!hasLineToImport	line := inputStream nextLine.	^ line notNil! !!CustomerImporter methodsFor: 'importing' stamp: 'AgustinDelger 6/25/2018 11:36'!readRecord	record := line substrings: {self fieldsDelimiter}! !!CustomerImporter methodsFor: 'importing' stamp: 'AgustinDelger 6/25/2018 11:36'!fieldsDelimiter	^ $,! !!CustomerImporter methodsFor: 'importing' stamp: 'AgustinDelger 6/25/2018 15:04'!isCustomerRecord	^ record first = 'C'! !!CustomerImporter methodsFor: 'importing' stamp: 'AD 6/26/2018 10:06'!import	[ self hasLineToImport ]		whileTrue: [ 			self readRecord.			self importRecord ]! !!CustomerImporter methodsFor: 'importing' stamp: 'AD 6/26/2018 10:37'!importCustomer		self assertRecordHasCorrectAmountOfFieldsForCustomer.	newCustomer := Customer new.	newCustomer firstName: record second.	newCustomer lastName: record third.	newCustomer identificationType: record fourth.	newCustomer identificationNumber: record fifth.	customerSystem add: newCustomer.! !!CustomerImporter methodsFor: 'importing' stamp: 'AgustinDelger 6/25/2018 15:04'!isAddressRecord	^ record first = 'A'! !!CustomerImporter methodsFor: 'importing' stamp: 'AgustinDelger 6/27/2018 12:41'!importRecord	self assertRecordIsNotEmpty.		self isCustomerRecord	ifTrue: [ ^ self importCustomer ].	self isAddressRecord	ifTrue: [ ^ self importAddress ].			self signalRecordHasInvalidType.! !!CustomerImporter methodsFor: 'importing' stamp: 'AD 6/28/2018 19:27'!numberOfFieldsInRecordIs: aNumberOfFields	^ (line occurrencesOf: self fieldsDelimiter) = (aNumberOfFields - 1) and: [ record size = aNumberOfFields ]! !!CustomerImporter methodsFor: 'importing' stamp: 'AgustinDelger 6/25/2018 11:32'!amountOfFieldsInCustomerRecord	^ 5.! !!CustomerImporter methodsFor: 'importing' stamp: 'AgustinDelger 6/25/2018 11:32'!amountOfFieldsInAddressRecord		^ 6.! !!CustomerImporter methodsFor: 'importing' stamp: 'AgustinDelger 6/25/2018 14:44'!importAddress	|  newAddress |		self assertACustomerHasBeenImported.	self assertRecordHasCorrectAmountOfFieldsForAddress.		newAddress := Address new.	newAddress streetName: record second.	newAddress streetNumber: record third asInteger.	newAddress town: record fourth.	newAddress zipCode: record fifth asInteger.	newAddress := newAddress.	newAddress province: record sixth.		newCustomer addAddress: newAddress! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CustomerImporter class	instanceVariableNames: ''!!CustomerImporter class methodsFor: 'instance creation' stamp: 'AD 6/26/2018 10:37'!from: anInputStream on: aCustomerSystem	^ self new initializeFrom: anInputStream on: aCustomerSystem.! !!CustomerImporter class methodsFor: 'error messages' stamp: 'AgustinDelger 6/25/2018 11:14'!invalidAmountOfFieldsInCustomerRecordErrorMessage	^ 'Invalid amount of fields in customer record'! !!CustomerImporter class methodsFor: 'error messages' stamp: 'AD 6/23/2018 17:32'!emptyRecordErrorMessage		^ 'Can not import an empty record'! !!CustomerImporter class methodsFor: 'error messages' stamp: 'AgustinDelger 6/25/2018 11:14'!invalidAmountOfFieldsInAddressRecordErrorMessage	^ 'Invalid amount of fields in address record'! !!CustomerImporter class methodsFor: 'error messages' stamp: 'AgustinDelger 6/25/2018 14:34'!addressRecordWithoutCustomerErrorMessage		^ 'An address record must be preceded by a customer record.'! !!CustomerImporter class methodsFor: 'error messages' stamp: 'AD 6/21/2018 20:28'!invalidRecordTypeErrorMessage^ 'Invalid record type'! !Object subclass: #CustomerSystem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!CustomerSystem methodsFor: 'queries' stamp: 'AD 6/25/2018 22:22'!customersIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber
	self subclassResponsibility! !!CustomerSystem methodsFor: 'queries' stamp: 'AD 6/30/2018 19:39'!containsCustomerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber
	self subclassResponsibility! !!CustomerSystem methodsFor: 'queries' stamp: 'AgustinDelger 6/30/2018 16:23'!customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ifNone: noneBlock
	self subclassResponsibility! !!CustomerSystem methodsFor: 'queries' stamp: 'AD 6/25/2018 22:22'!amountOfCustomersImported
	self subclassResponsibility! !!CustomerSystem methodsFor: 'session operations' stamp: 'AD 6/25/2018 22:22'!start
	self subclassResponsibility! !!CustomerSystem methodsFor: 'session operations' stamp: 'AD 6/26/2018 09:43'!stop
	self subclassResponsibility! !!CustomerSystem methodsFor: 'adding' stamp: 'AD 6/26/2018 10:40'!add: aCustomer
	self subclassResponsibility! !Object subclass: #CustomersTestDataFactory	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!CustomersTestDataFactory methodsFor: 'test data' stamp: 'AgustinDelger 6/25/2018 14:33'!addressRecordFirstTestData	^ ReadStream on:'A,San Martin,3322,Olivos,1636,BsAsC,Pepe,Sanchez,D,22333444A,Maipu,888,Florida,1122,Buenos AiresC,Juan,Perez,C,23-25666777-9A,Alem,1122,CABA,1001,CABA'! !!CustomersTestDataFactory methodsFor: 'test data' stamp: 'AgustinDelger 6/25/2018 10:45'!addressRecordWithTooFewFieldsTestData	^ ReadStream on:'C,Pepe,Sanchez,D,22333444A,San Martin'! !!CustomersTestDataFactory methodsFor: 'test data' stamp: 'AD 6/28/2018 19:27'!validTestData	^ ReadStream on:'C,Pepe,Sanchez,D,22333444A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos AiresC,Juan,Perez,C,23-25666777-9A,Alem,1122,CABA,1001,CABA'! !!CustomersTestDataFactory methodsFor: 'test data' stamp: 'AgustinDelger 6/25/2018 10:40'!invalidRecordTypeTestData	^ ReadStream on:'AX,Pepe,Sanchez,D,22333444'! !!CustomersTestDataFactory methodsFor: 'test data' stamp: 'AgustinDelger 6/25/2018 10:42'!customerRecordWithTooFewFieldsTestData	^ ReadStream on:'C,Pepe,Sanchez'! !!CustomersTestDataFactory methodsFor: 'test data' stamp: 'AgustinDelger 6/25/2018 10:43'!customerRecordWithExtraCommaTestData	^ ReadStream on:'C,Pepe,Sanchez,D,22333444,'! !!CustomersTestDataFactory methodsFor: 'test data' stamp: 'AgustinDelger 6/25/2018 11:20'!addressRecordWithExtraCommaTestData	^ ReadStream on:'C,Pepe,Sanchez,D,22333444A,San Martin,,3322,Olivos,1636,BsAs'! !!CustomersTestDataFactory methodsFor: 'test data' stamp: 'AgustinDelger 6/25/2018 10:44'!addressRecordWithTooManyFieldsTestData	^ ReadStream on:'C,Pepe,Sanchez,D,22333444A,San Martin,3322,Olivos,1636,BsAs,Argentina'! !!CustomersTestDataFactory methodsFor: 'test data' stamp: 'AgustinDelger 6/25/2018 10:41'!emptyRecordTestData	^ ReadStream on:'C,Pepe,Sanchez,D,22333444A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos Aires'! !!CustomersTestDataFactory methodsFor: 'test data' stamp: 'AgustinDelger 6/25/2018 10:42'!customerRecordWithTooManyFieldsTestData	^ ReadStream on:'C,Pepe,Sanchez,D,22333444,57kg'! !Object subclass: #Environment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!Environment methodsFor: 'system creation' stamp: 'AD 6/30/2018 23:47'!createSupplierSystem	^ self subclassResponsibility.! !!Environment methodsFor: 'system creation' stamp: 'AD 6/25/2018 23:07'!createCustomerSystem	^ self subclassResponsibility.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Environment class	instanceVariableNames: ''!!Environment class methodsFor: 'error messages' stamp: 'AD 6/25/2018 22:59'!invalidEnvironmentErrorMessage	^ 'Invalid environment'! !!Environment class methodsFor: 'accessing' stamp: 'AD 6/25/2018 23:04'!current	^ (self subclasses detect: [:anEnvironment | anEnvironment isCurrent] ifNone: [self error: self invalidEnvironmentErrorMessage]) new.! !Environment subclass: #DevelopmentEnvironment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!DevelopmentEnvironment methodsFor: 'system creation' stamp: 'AD 6/30/2018 22:02'!createSupplierSystem	 	^ TransientSupplierSystem new! !!DevelopmentEnvironment methodsFor: 'system creation' stamp: 'AD 6/25/2018 23:07'!createCustomerSystem	 	^ TransientCustomerSystem new! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DevelopmentEnvironment class	instanceVariableNames: ''!!DevelopmentEnvironment class methodsFor: 'testing' stamp: 'AD 6/30/2018 23:56'!isCurrent	^ true.! !Environment subclass: #IntegrationEnvironment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!IntegrationEnvironment methodsFor: 'system creation' stamp: 'AD 6/30/2018 23:46'!createSupplierSystem	 	^ PersistentSupplierSystem new! !!IntegrationEnvironment methodsFor: 'system creation' stamp: 'AD 6/25/2018 23:08'!createCustomerSystem	 	^ PersistentCustomerSystem new! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!IntegrationEnvironment class	instanceVariableNames: ''!!IntegrationEnvironment class methodsFor: 'testing' stamp: 'AgustinDelger 6/30/2018 16:31'!isCurrent	^ DevelopmentEnvironment isCurrent not.! !Object subclass: #Party	instanceVariableNames: 'id identificationType identificationNumber addresses'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!Party methodsFor: 'queries' stamp: 'AgustinDelger 6/30/2018 17:38'!isIdentifiedAs: idType numbered: idNumber 		^ identificationType = idType and: [ identificationNumber = idNumber ]! !!Party methodsFor: 'addresses' stamp: 'AgustinDelger 6/30/2018 17:33'!addAddress: anAddress 		addresses add: anAddress ! !!Party methodsFor: 'addresses' stamp: 'AgustinDelger 6/30/2018 17:33'!addressAt: aStreetName ifNone: noneClosure 		^addresses detect: [ :anAddress | anAddress isAt: aStreetName ] ifNone: noneClosure ! !!Party methodsFor: 'addresses' stamp: 'AgustinDelger 6/30/2018 17:33'!numberOfAddresses		^ addresses size.! !!Party methodsFor: 'identification' stamp: 'AgustinDelger 6/30/2018 17:33'!identificationType: anIdType 		identificationType := anIdType.! !!Party methodsFor: 'identification' stamp: 'AgustinDelger 6/30/2018 17:32'!identificationNumber: anIdNumber	identificationNumber := anIdNumber ! !!Party methodsFor: 'identification' stamp: 'AgustinDelger 6/30/2018 17:33'!identificationType	^ identificationType! !!Party methodsFor: 'identification' stamp: 'AgustinDelger 6/30/2018 17:32'!identificationNumber	^ identificationNumber! !Party subclass: #Customer	instanceVariableNames: 'firstName lastName'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 13:09'!firstName: aName 	firstName := aName! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 16:15'!lastName	^lastName ! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 16:15'!firstName		^firstName ! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 13:09'!lastName: aLastName 	lastName := aLastName! !!Customer methodsFor: 'addresses' stamp: 'HernanWilkinson 11/1/2016 09:43'!numberOfAddresses		^addresses size! !!Customer methodsFor: 'addresses' stamp: 'HernanWilkinson 10/28/2016 13:25'!addresses	^ addresses! !!Customer methodsFor: 'addresses' stamp: 'HernanWilkinson 11/1/2016 10:05'!addressAt: aStreetName ifNone: noneClosure 		^addresses detect: [ :anAddress | anAddress isAt: aStreetName ] ifNone: noneClosure ! !!Customer methodsFor: 'addresses' stamp: 'HernanWilkinson 10/28/2016 13:27'!addAddress: anAddress 	addresses add: anAddress ! !!Customer methodsFor: 'identification' stamp: 'HernanWilkinson 10/28/2016 13:10'!identificationType: anIdentificationType 	identificationType := anIdentificationType! !!Customer methodsFor: 'identification' stamp: 'HernanWilkinson 10/28/2016 13:10'!identificationNumber: anIdentificationNumber 	identificationNumber := anIdentificationNumber! !!Customer methodsFor: 'identification' stamp: 'HernanWilkinson 10/28/2016 16:13'!identificationNumber		^identificationNumber ! !!Customer methodsFor: 'identification' stamp: 'HernanWilkinson 10/28/2016 16:13'!identificationType		^identificationType ! !!Customer methodsFor: 'initialization' stamp: 'HernanWilkinson 10/28/2016 13:26'!initialize	super initialize.	addresses := OrderedCollection new.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Customer class	instanceVariableNames: ''!!Customer class methodsFor: 'importing' stamp: 'HernanWilkinson 11/1/2016 08:39'!importCustomers	"	self importCustomers	"	| inputStream session newCustomer line |		inputStream := FileStream fileNamed: 'input.txt'.	session := DataBaseSession for: (Array 		with: (ClassMapping 			withDefaultTableNameFor: Address 			mappingAll: (Array 				with: (EmbededMapping withDefaultFieldNameFor: #streetName)				with: (EmbededMapping withDefaultFieldNameFor: #streetNumber)				with: (EmbededMapping withDefaultFieldNameFor: #town)				with: (EmbededMapping withDefaultFieldNameFor: #zipCode)				with: (EmbededMapping withDefaultFieldNameFor: #province))) 		with: (ClassMapping 			withDefaultTableNameFor: Customer 			mappingAll: (Array 				with: (EmbededMapping withDefaultFieldNameFor: #firstName)				with: (EmbededMapping withDefaultFieldNameFor: #lastName)				with: (EmbededMapping withDefaultFieldNameFor: #identificationType)				with: (EmbededMapping withDefaultFieldNameFor: #identificationNumber)				with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address)))).	session open.	session beginTransaction.	line := inputStream nextLine.	[ line notNil ] whileTrue: [ 		(line beginsWith: 'C') ifTrue: [ | customerData |			customerData := line substrings: {$,}.			newCustomer := Customer new.			newCustomer firstName: customerData second.			newCustomer lastName: customerData third.			newCustomer identificationType: customerData fourth.			newCustomer identificationNumber: customerData fourth.			session persist: newCustomer ].				(line beginsWith: 'A') ifTrue: [ | addressData newAddress |			addressData := line substrings: { $, }.			newAddress := Address new.			newAddress streetName: addressData second.			newAddress streetNumber: addressData third asInteger. 			newAddress town: addressData fourth.			newAddress zipCode: addressData fifth asInteger.			newAddress province: addressData fourth.			newCustomer addAddress: newAddress. ].						line := inputStream nextLine. ].					session commit.		session close.				inputStream close.		! !CustomerSystem subclass: #PersistentCustomerSystem	instanceVariableNames: 'session'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!PersistentCustomerSystem methodsFor: 'queries' stamp: 'AgustinDelger 6/25/2018 13:39'!customersIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber	^ session		select: [ :aCustomer | 			aCustomer identificationType = anIdentifycationType				and: [ aCustomer identificationNumber = anIdentificationNumber ] ]		ofType: Customer! !!PersistentCustomerSystem methodsFor: 'queries' stamp: 'AD 6/30/2018 19:41'!containsCustomerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber	self customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ifNone: [^ false].	^ true.! !!PersistentCustomerSystem methodsFor: 'queries' stamp: 'AgustinDelger 6/30/2018 17:43'!customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ifNone: noneBlock	| customerMatches |	customerMatches := session		select: [ :aCustomer | 			aCustomer isIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ]		ofType: Customer.			customerMatches isEmpty ifTrue: [ noneBlock value ].		^ customerMatches anyOne.! !!PersistentCustomerSystem methodsFor: 'queries' stamp: 'AgustinDelger 6/25/2018 12:20'!amountOfCustomersImported	^ (session selectAllOfType: Customer) size! !!PersistentCustomerSystem methodsFor: 'mapping' stamp: 'AgustinDelger 6/25/2018 12:07'!customerMapping	^ ClassMapping		withDefaultTableNameFor: Customer		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #firstName)				with: (EmbededMapping withDefaultFieldNameFor: #lastName)				with: (EmbededMapping withDefaultFieldNameFor: #identificationType)				with: (EmbededMapping withDefaultFieldNameFor: #identificationNumber)				with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address))! !!PersistentCustomerSystem methodsFor: 'mapping' stamp: 'AgustinDelger 6/25/2018 12:05'!addressMapping	^ ClassMapping		withDefaultTableNameFor: Address		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #streetName)				with: (EmbededMapping withDefaultFieldNameFor: #streetNumber)				with: (EmbededMapping withDefaultFieldNameFor: #town)				with: (EmbededMapping withDefaultFieldNameFor: #zipCode)				with: (EmbededMapping withDefaultFieldNameFor: #province))! !!PersistentCustomerSystem methodsFor: 'adding' stamp: 'AD 6/26/2018 10:38'!add: aCustomer	session persist: aCustomer.! !!PersistentCustomerSystem methodsFor: 'initialization' stamp: 'AgustinDelger 6/25/2018 13:53'!initialize	session := DataBaseSession				 for:					(Array with:						self addressMapping with:						self customerMapping).! !!PersistentCustomerSystem methodsFor: 'session operations' stamp: 'AgustinDelger 6/27/2018 12:33'!start	session open.	session beginTransaction! !!PersistentCustomerSystem methodsFor: 'session operations' stamp: 'AgustinDelger 6/27/2018 12:34'!stop	session commit.	session close! !Party subclass: #Supplier	instanceVariableNames: 'fullName customers'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!Supplier methodsFor: 'identification' stamp: 'AD 6/28/2018 20:28'!identificationNumber: anIdNumber	identificationNumber := anIdNumber ! !!Supplier methodsFor: 'identification' stamp: 'AD 6/28/2018 20:28'!identificationType: anIdType 		identificationType := anIdType.! !!Supplier methodsFor: 'identification' stamp: 'AD 6/28/2018 20:42'!identificationNumber	^ identificationNumber! !!Supplier methodsFor: 'identification' stamp: 'AD 6/28/2018 20:41'!identificationType	^ identificationType! !!Supplier methodsFor: 'name' stamp: 'AD 6/28/2018 20:46'!fullName	^ fullName! !!Supplier methodsFor: 'name' stamp: 'AD 6/28/2018 20:27'!fullName: aName 		fullName := aName! !!Supplier methodsFor: 'addresses' stamp: 'AD 6/28/2018 20:30'!addAddress: anAddress 		addresses add: anAddress ! !!Supplier methodsFor: 'addresses' stamp: 'AD 6/28/2018 20:50'!addressAt: aStreetName ifNone: noneClosure 		^addresses detect: [ :anAddress | anAddress isAt: aStreetName ] ifNone: noneClosure ! !!Supplier methodsFor: 'addresses' stamp: 'AgustinDelger 6/30/2018 15:50'!addCustomer: aCustomer 		customers add: aCustomer.! !!Supplier methodsFor: 'addresses' stamp: 'AD 6/28/2018 20:47'!numberOfAddresses		^ addresses size.! !!Supplier methodsFor: 'initialization' stamp: 'AD 6/28/2018 20:47'!initialize	addresses := OrderedCollection new.	customers := OrderedCollection new.! !!Supplier methodsFor: 'customers' stamp: 'AD 6/28/2018 20:46'!numberOfCustomers		^ customers size.! !!Supplier methodsFor: 'customers' stamp: 'AgustinDelger 6/30/2018 17:34'!customerIdentifiedAs: idType numbered: idNumber ifNone: noneBlock 		^ customers detect: [ :aCustomer | aCustomer isIdentifiedAs: idType numbered: idNumber ] ifNone: noneBlock ! !TestCase subclass: #SupplierImportTest	instanceVariableNames: 'supplierSystem customerSystem'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!SupplierImportTest methodsFor: 'test data' stamp: 'AD 6/30/2018 20:00'!addressRecordFirstTestData	^ ReadStream on: 'A,San Martin,3322,Olivos,1636,BsAsS,Supplier1,D,123'! !!SupplierImportTest methodsFor: 'test data' stamp: 'AgustinDelger 6/30/2018 17:17'!validTestDataForSupplierWithAnExistingCustomerRecord	^ ReadStream on: 'S,Supplier1,D,123EC,D,22333444'! !!SupplierImportTest methodsFor: 'test data' stamp: 'AD 6/30/2018 21:41'!addressRecordWithTooFewFieldsTestData	^ ReadStream on: 'S,Supplier1,D,123A,San Martin,3322'! !!SupplierImportTest methodsFor: 'test data' stamp: 'AD 6/30/2018 20:18'!supplierRecordWithExtraCommaTestData	^ ReadStream on: 'S,Supplier1,D,123,'! !!SupplierImportTest methodsFor: 'test data' stamp: 'AD 6/30/2018 21:17'!newCustomerRecordWithTooManyFieldsTestData	^ ReadStream on: 'S,Supplier1,D,123NC,Pepe,Sanchez,D,22333444,87Kg'! !!SupplierImportTest methodsFor: 'test data' stamp: 'AgustinDelger 6/30/2018 17:16'!validTestDataForSupplierWithANewCustomerRecord	^ ReadStream on: 'S,Supplier1,D,123NC,Pepe,Sanchez,D,22333444'! !!SupplierImportTest methodsFor: 'test data' stamp: 'AD 6/28/2018 19:50'!invalidRecordTypeTestData	^ ReadStream on: 'SX,Supplier1,D,123'! !!SupplierImportTest methodsFor: 'test data' stamp: 'AD 6/30/2018 21:18'!existingCustomerRecordWithExtraCommaTestData	^ ReadStream on: 'S,Supplier1,D,123EC,D,22333444,'! !!SupplierImportTest methodsFor: 'test data' stamp: 'AD 6/30/2018 21:02'!newCustomerRecordWithExtraCommaTestData	^ ReadStream on: 'S,Supplier1,D,123NC,Pepe,Sanchez,D,22333444,'! !!SupplierImportTest methodsFor: 'test data' stamp: 'AgustinDelger 6/30/2018 17:07'!validTestDataForSupplierWithAnAddressesRecord	^ ReadStream on: 'S,Supplier1,D,123A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos Aires'! !!SupplierImportTest methodsFor: 'test data' stamp: 'AD 6/30/2018 21:36'!addressRecordWithExtraCommaTestData	^ ReadStream on: 'S,Supplier1,D,123A,San Martin,3322,Olivos,1636,BsAs,'! !!SupplierImportTest methodsFor: 'test data' stamp: 'AD 6/30/2018 21:22'!existingCustomerRecordWithTooManyFieldsTestData	^ ReadStream on: 'S,Supplier1,D,123EC,D,22333444,Pepe,Sanchez'! !!SupplierImportTest methodsFor: 'test data' stamp: 'AD 6/30/2018 20:53'!supplierRecordWithTooFewFieldsTestData	^ ReadStream on: 'S,Supplier1'! !!SupplierImportTest methodsFor: 'test data' stamp: 'AD 6/30/2018 21:40'!addressRecordWithTooManyFieldsTestData	^ ReadStream on: 'S,Supplier1,D,123A,San Martin,3322,Olivos,1636,BsAs,Argentina'! !!SupplierImportTest methodsFor: 'test data' stamp: 'AD 6/30/2018 20:28'!supplierRecordWithTooManyFieldsTestData	^ ReadStream on: 'S,Supplier1,D,123,08100001234'! !!SupplierImportTest methodsFor: 'test data' stamp: 'AD 6/30/2018 19:53'!emptyRecordTestData	^ ReadStream on: 'S,Supplier1,D,123A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos Aires'! !!SupplierImportTest methodsFor: 'test data' stamp: 'AD 6/30/2018 21:27'!existingCustomerRecordWithTooFewFieldsTestData	^ ReadStream on: 'S,Supplier1,D,123EC,D,'! !!SupplierImportTest methodsFor: 'test data' stamp: 'AD 6/30/2018 21:23'!newCustomerRecordWithTooFewFieldsTestData	^ ReadStream on: 'S,Supplier1,D,123NC,Pepe,Sanchez'! !!SupplierImportTest methodsFor: 'testing - customer' stamp: 'AgustinDelger 6/30/2018 17:28'!testCantImportExistingCustomerRecordIfCustomerDoesNotExist	"The existing customer imported is not added to the customer system first"	self		shouldImportingSuppliersFrom: self validTestDataForSupplierWithAnExistingCustomerRecord		raiseErrorDo: [ :anError | 			self				assert: anError messageText				equals: SupplierImporter customerDoesNotExistErrorMessage.			self assertImportedSuppliersSizeIs: 1.			self assertSupplier1WasImportedWithNoCustomersOrAddresses ]! !!SupplierImportTest methodsFor: 'testing - customer' stamp: 'AD 6/30/2018 21:29'!testCantImportExistingCustomerRecordWithTooManyFields		self addPepeSanchezToCustomerSystem.	self		shouldImportingSuppliersFrom: self existingCustomerRecordWithTooManyFieldsTestData		raiseErrorDo: [ :anError | 			self				assert: anError messageText				equals: SupplierImporter invalidAmountOfFieldsInExistingCustomerRecordErrorMessage.			self assertSupplier1WasImportedWithNoCustomersOrAddresses ]! !!SupplierImportTest methodsFor: 'testing - customer' stamp: 'AD 6/30/2018 21:16'!testCantImportNewCustomerRecordWithTooManyFields	self		shouldImportingSuppliersFrom: self newCustomerRecordWithTooManyFieldsTestData		raiseErrorDo: [ :anError | 			self				assert: anError messageText				equals: SupplierImporter invalidAmountOfFieldsInNewCustomerRecordErrorMessage.			self assertSupplier1WasImportedWithNoCustomersOrAddresses ]! !!SupplierImportTest methodsFor: 'testing - customer' stamp: 'AD 6/30/2018 21:29'!testCantImportExistingCustomerRecordWithExtraCommas	self addPepeSanchezToCustomerSystem.	self		shouldImportingSuppliersFrom: self existingCustomerRecordWithExtraCommaTestData		raiseErrorDo: [ :anError | 			self				assert: anError messageText				equals: SupplierImporter invalidAmountOfFieldsInExistingCustomerRecordErrorMessage.			self assertSupplier1WasImportedWithNoCustomersOrAddresses]! !!SupplierImportTest methodsFor: 'testing - customer' stamp: 'AD 6/30/2018 21:23'!testCantImportNewCustomerRecordWithTooFewFields	self		shouldImportingSuppliersFrom: self newCustomerRecordWithTooFewFieldsTestData		raiseErrorDo: [ :anError | 			self				assert: anError messageText				equals: SupplierImporter invalidAmountOfFieldsInNewCustomerRecordErrorMessage.			self assertSupplier1WasImportedWithNoCustomersOrAddresses ]! !!SupplierImportTest methodsFor: 'testing - customer' stamp: 'AD 6/30/2018 21:29'!testCantImportExistingCustomerRecordWithTooFewFields		self addPepeSanchezToCustomerSystem.	self		shouldImportingSuppliersFrom: self existingCustomerRecordWithTooFewFieldsTestData		raiseErrorDo: [ :anError | 			self				assert: anError messageText				equals: SupplierImporter invalidAmountOfFieldsInExistingCustomerRecordErrorMessage.			self assertSupplier1WasImportedWithNoCustomersOrAddresses ]! !!SupplierImportTest methodsFor: 'testing - customer' stamp: 'AgustinDelger 6/30/2018 18:22'!testCantImportNewCustomerRecordIfCustomerAlreadyExists		self addPepeSanchezToCustomerSystem.	self		shouldImportingSuppliersFrom: self validTestDataForSupplierWithANewCustomerRecord		raiseErrorDo: [ :anError | 			self				assert: anError messageText				equals: SupplierImporter customerAlreadyExistsErrorMessage.			self assertImportedSuppliersSizeIs: 1.			self assertSupplier1WasImportedWithNoCustomersOrAddresses ]! !!SupplierImportTest methodsFor: 'testing - customer' stamp: 'AD 6/30/2018 21:29'!testCantImportNewCustomerRecordWithExtraCommas	self		shouldImportingSuppliersFrom: self newCustomerRecordWithExtraCommaTestData		raiseErrorDo: [ :anError | 			self				assert: anError messageText				equals: SupplierImporter invalidAmountOfFieldsInNewCustomerRecordErrorMessage.			self assertSupplier1WasImportedWithNoCustomersOrAddresses]! !!SupplierImportTest methodsFor: 'testing - address' stamp: 'AD 6/30/2018 21:41'!testCantImportAddressRecordWithTooFewFields	self		shouldImportingSuppliersFrom: self addressRecordWithTooFewFieldsTestData		raiseErrorDo: [ :anError | 			self				assert: anError messageText				equals: SupplierImporter invalidAmountOfFieldsInAddressRecordErrorMessage.			self assertSupplier1WasImportedWithNoCustomersOrAddresses]! !!SupplierImportTest methodsFor: 'testing - address' stamp: 'AD 6/30/2018 21:35'!testCantImportAddressRecordWithExtraCommas	self		shouldImportingSuppliersFrom: self addressRecordWithExtraCommaTestData		raiseErrorDo: [ :anError | 			self				assert: anError messageText				equals: SupplierImporter invalidAmountOfFieldsInAddressRecordErrorMessage.			self assertSupplier1WasImportedWithNoCustomersOrAddresses]! !!SupplierImportTest methodsFor: 'testing - address' stamp: 'AD 6/30/2018 21:39'!testCantImportAddressRecordWithTooManyFields	self		shouldImportingSuppliersFrom: self addressRecordWithTooManyFieldsTestData		raiseErrorDo: [ :anError | 			self				assert: anError messageText				equals: SupplierImporter invalidAmountOfFieldsInAddressRecordErrorMessage.			self assertSupplier1WasImportedWithNoCustomersOrAddresses]! !!SupplierImportTest methodsFor: 'importing' stamp: 'AgustinDelger 6/30/2018 17:02'!importSuppliersFrom: testData	| supplierImporter |		supplierImporter := SupplierImporter		from: testData		on: supplierSystem		withCustomersIn: customerSystem.	supplierImporter import! !!SupplierImportTest methodsFor: 'importing' stamp: 'AD 6/28/2018 19:53'!shouldImportingSuppliersFrom: testData raiseErrorDo: errorBlock 	| supplierImporter |	supplierImporter := SupplierImporter from: testData on: supplierSystem withCustomersIn: customerSystem.	self		should: [ supplierImporter import ]		raise: Error		withExceptionDo: [ :anError | errorBlock value: anError ]! !!SupplierImportTest methodsFor: 'assertions' stamp: 'AD 6/28/2018 20:32'!assertImportedSuppliersSizeIs: anAmountOfSuppliers 		self assert: supplierSystem amountOfSuppliersImported equals: anAmountOfSuppliers.! !!SupplierImportTest methodsFor: 'assertions' stamp: 'AgustinDelger 6/30/2018 17:25'!assertSupplier1WasImportedCorrectlyWithAddressesOnly	| supplier idType idNumber |	idType := 'D'.	idNumber := '123'.	supplier := self supplierIdentifiedAs: idType numbered: idNumber.	self		assert: supplier		isNamed: 'Supplier1'		identfiedAs: idType		withNumber: idNumber		numberOfCustomers: 0		andNumberOfAddresses: 2.	self		assert: supplier		hasAddressAt: 'San Martin'		number: 3322		in: 'Olivos'		zipCode: 1636		province: 'BsAs'.	self		assert: supplier		hasAddressAt: 'Maipu'		number: 888		in: 'Florida'		zipCode: 1122		province: 'Buenos Aires'! !!SupplierImportTest methodsFor: 'assertions' stamp: 'AgustinDelger 6/30/2018 17:25'!assertSupplier1WasImportedCorrectlyWithPepeSanchezAsCustomer	| supplier idType idNumber |	idType := 'D'.	idNumber := '123'.	supplier := self supplierIdentifiedAs: idType numbered: idNumber.	self		assert: supplier		isNamed: 'Supplier1'		identfiedAs: idType		withNumber: idNumber		numberOfCustomers: 1		andNumberOfAddresses: 0.	self		assert: supplier		hasCustomerNamed: 'Pepe'		lastName: 'Sanchez'		identfiedAs: 'D'		withNumber: '22333444'		andNumberOfAddresses: 0! !!SupplierImportTest methodsFor: 'assertions' stamp: 'AgustinDelger 6/30/2018 16:39'!assert: supplier hasCustomerNamed: firstName lastName: lastName identfiedAs: idType withNumber: idNumber andNumberOfAddresses: addressesSize	| customer |		customer := supplier		customerIdentifiedAs: idType		numbered: idNumber		ifNone: [ self fail ].			self assert: customer isNamed: firstName lastName: lastName identfiedAs: idType withNumber: idNumber andNumberOfAddresses: addressesSize.! !!SupplierImportTest methodsFor: 'assertions' stamp: 'AgustinDelger 6/30/2018 17:22'!assertNoSuppliersWereImported	self assertImportedSuppliersSizeIs: 0.! !!SupplierImportTest methodsFor: 'assertions' stamp: 'AgustinDelger 6/30/2018 16:10'!assert: customer isNamed: firstName lastName: lastName identfiedAs: idType withNumber: idNumber andNumberOfAddresses: addressesSize	self assert: customer firstName equals: firstName.	self assert: customer lastName equals: lastName.	self assert: customer identificationType equals: idType.	self assert: customer identificationNumber equals: idNumber.	self assert: customer numberOfAddresses equals: addressesSize .! !!SupplierImportTest methodsFor: 'assertions' stamp: 'AgustinDelger 6/30/2018 17:21'!assertPepeSanchezWasAddedToCustomerSystem	| customer idType idNumber |	idType := 'D'.	idNumber := '22333444'.	customer := self customerIdentifiedAs: idType numbered: idNumber.		self assert: customer isNamed: 'Pepe' lastName: 'Sanchez' identfiedAs: idType withNumber: idNumber andNumberOfAddresses: 0.		! !!SupplierImportTest methodsFor: 'assertions' stamp: 'AgustinDelger 6/30/2018 17:25'!assertSupplier1WasImportedWithNoCustomersOrAddresses	| supplier idType idNumber |	idType := 'D'.	idNumber := '123'.	supplier := self supplierIdentifiedAs: idType numbered: idNumber.	self		assert: supplier		isNamed: 'Supplier1'		identfiedAs: idType		withNumber: idNumber		numberOfCustomers: 0		andNumberOfAddresses: 0! !!SupplierImportTest methodsFor: 'assertions' stamp: 'AD 6/28/2018 20:45'!assert: aSupplier isNamed: aName identfiedAs: idType withNumber: idNumber numberOfCustomers: customersSize andNumberOfAddresses: addressesSize 	self assert: aSupplier fullName equals: aName.	self assert: aSupplier identificationType equals: idType.	self assert: aSupplier identificationNumber equals: idNumber.	self assert: aSupplier numberOfCustomers equals: customersSize.	self assert: aSupplier numberOfAddresses equals: addressesSize.! !!SupplierImportTest methodsFor: 'assertions' stamp: 'AD 6/28/2018 20:49'!assert: supplier hasAddressAt: streetName number: streetNumber in: town zipCode: zipCode province: province	| address |		address := supplier addressAt: streetName ifNone: [ self fail ].	self assert: address streetName equals: streetName.	self assert: address streetNumber equals: streetNumber.	self assert: address town equals: town.	self assert: address zipCode equals: zipCode.	self assert: address province equals: province.! !!SupplierImportTest methodsFor: 'setup-teardown' stamp: 'AD 6/30/2018 22:02'!setUp	supplierSystem := Environment current createSupplierSystem.	supplierSystem start.	customerSystem := Environment current createCustomerSystem.	customerSystem start.! !!SupplierImportTest methodsFor: 'setup-teardown' stamp: 'AD 6/30/2018 23:45'!tearDown	customerSystem stop.	supplierSystem stop.! !!SupplierImportTest methodsFor: 'support' stamp: 'AgustinDelger 6/30/2018 17:23'!customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber	^ customerSystem		customerIdentifiedAs: anIdentifycationType		numbered: anIdentificationNumber		ifNone: [ self fail ].! !!SupplierImportTest methodsFor: 'support' stamp: 'AgustinDelger 6/30/2018 16:56'!addPepeSanchezToCustomerSystem	| customer |		customer := Customer new.	customer firstName: 'Pepe'.	customer lastName: 'Sanchez'.	customer identificationType: 'D'.	customer identificationNumber: '22333444'.	customerSystem add: customer! !!SupplierImportTest methodsFor: 'support' stamp: 'AgustinDelger 6/30/2018 17:26'!supplierIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber	^ supplierSystem		supplierIdentifiedAs: anIdentifycationType		numbered: anIdentificationNumber		ifNone: [ self fail ]! !!SupplierImportTest methodsFor: 'testing - general' stamp: 'AD 6/28/2018 19:36'!testCantImportRecordWithAnInvalidType	self		shouldImportingSuppliersFrom: self invalidRecordTypeTestData		raiseErrorDo: [ :anError | 			self				assert: anError messageText				equals: SupplierImporter invalidRecordTypeErrorMessage.			self assertNoSuppliersWereImported ]! !!SupplierImportTest methodsFor: 'testing - general' stamp: 'AD 6/30/2018 19:59'!testCantImportAddressRecordWithoutImportingSupplierRecordFirst	self		shouldImportingSuppliersFrom: self addressRecordFirstTestData		raiseErrorDo: [ :anError | 			self				assert: anError messageText				equals: SupplierImporter addressRecordWithoutSupplierErrorMessage.			self assertNoSuppliersWereImported ]! !!SupplierImportTest methodsFor: 'testing - general' stamp: 'AgustinDelger 6/30/2018 17:29'!testSupplierImporterImportsCorrectlySupplierWithNewCustomersOnly	self importSuppliersFrom: self validTestDataForSupplierWithANewCustomerRecord.		self assertImportedSuppliersSizeIs: 1.	self assertSupplier1WasImportedCorrectlyWithPepeSanchezAsCustomer.	self assertPepeSanchezWasAddedToCustomerSystem! !!SupplierImportTest methodsFor: 'testing - general' stamp: 'AgustinDelger 6/30/2018 17:17'!testSupplierImporterImportsCorrectlySupplierWithExistingCustomersOnly		self addPepeSanchezToCustomerSystem.		self importSuppliersFrom:  self validTestDataForSupplierWithAnExistingCustomerRecord.		self assertImportedSuppliersSizeIs: 1.	self assertSupplier1WasImportedCorrectlyWithPepeSanchezAsCustomer! !!SupplierImportTest methodsFor: 'testing - general' stamp: 'AgustinDelger 6/30/2018 17:07'!testSupplierImporterImportsCorrectlySupplierWithAddressesOnly	self importSuppliersFrom: self validTestDataForSupplierWithAnAddressesRecord.		self assertImportedSuppliersSizeIs: 1.	self assertSupplier1WasImportedCorrectlyWithAddressesOnly! !!SupplierImportTest methodsFor: 'testing - general' stamp: 'AD 6/30/2018 20:14'!testCantImportAnEmptyRecord	self		shouldImportingSuppliersFrom: self emptyRecordTestData		raiseErrorDo: [ :anError | 			self				assert: anError messageText				equals: SupplierImporter emptyRecordErrorMessage.			self assertImportedSuppliersSizeIs: 1.			self assertSupplier1WasImportedWithNoCustomersOrAddresses			]! !!SupplierImportTest methodsFor: 'testing  - supplier' stamp: 'AD 6/30/2018 21:30'!testCantImportSupplierRecordsWithTooFewFields	self		shouldImportingSuppliersFrom: self supplierRecordWithTooFewFieldsTestData		raiseErrorDo: [ :anError | 			self				assert: anError messageText				equals: SupplierImporter invalidAmountOfFieldsInSupplierRecordErrorMessage.			self assertNoSuppliersWereImported ]! !!SupplierImportTest methodsFor: 'testing  - supplier' stamp: 'AD 6/30/2018 21:30'!testCantImportSupplierRecordWithExtraCommas	self		shouldImportingSuppliersFrom: self supplierRecordWithExtraCommaTestData		raiseErrorDo: [ :anError | 			self				assert: anError messageText				equals: SupplierImporter invalidAmountOfFieldsInSupplierRecordErrorMessage.			self assertNoSuppliersWereImported ]! !!SupplierImportTest methodsFor: 'testing  - supplier' stamp: 'AD 6/30/2018 21:31'!testCantImportSupplierRecordWithTooManyFields	self		shouldImportingSuppliersFrom: self supplierRecordWithTooManyFieldsTestData		raiseErrorDo: [ :anError | 			self				assert: anError messageText				equals: SupplierImporter invalidAmountOfFieldsInSupplierRecordErrorMessage.			self assertNoSuppliersWereImported ]! !Object subclass: #SupplierImporter	instanceVariableNames: 'inputStream record line customerSystem supplierSystem newSupplier'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!SupplierImporter methodsFor: 'error signalling' stamp: 'AgustinDelger 6/30/2018 18:03'!signalCustomerAlreadyExists		self error: self class customerAlreadyExistsErrorMessage.! !!SupplierImporter methodsFor: 'error signalling' stamp: 'AgustinDelger 6/30/2018 16:43'!signalCustomerDoesNotExistError		self error: self class customerDoesNotExistErrorMessage.! !!SupplierImporter methodsFor: 'importing' stamp: 'AD 6/28/2018 20:25'!importSupplier	self assertRecordHasCorrectAmountOfFieldsForSupplier.	newSupplier := Supplier new.	newSupplier fullName: record second.	newSupplier identificationType: record third.	newSupplier identificationNumber: record fourth.		supplierSystem add: newSupplier.! !!SupplierImporter methodsFor: 'importing' stamp: 'AD 6/28/2018 19:34'!readRecord	record := line substrings: {self fieldsDelimiter}! !!SupplierImporter methodsFor: 'importing' stamp: 'AD 6/28/2018 19:37'!amountOfFieldsInNewCustomerRecord	^ 5.! !!SupplierImporter methodsFor: 'importing' stamp: 'AD 6/28/2018 19:34'!fieldsDelimiter	^ $,! !!SupplierImporter methodsFor: 'importing' stamp: 'AD 6/30/2018 21:20'!amountOfFieldsInSupplierRecord		^ 4! !!SupplierImporter methodsFor: 'importing' stamp: 'AgustinDelger 6/30/2018 18:31'!import	[ self hasLineToImport ]		whileTrue: [ 			self readRecord.			self importRecord ]! !!SupplierImporter methodsFor: 'importing' stamp: 'AgustinDelger 6/30/2018 16:18'!isExistingCustomerRecord		^ record first = 'EC'! !!SupplierImporter methodsFor: 'importing' stamp: 'AD 6/30/2018 21:21'!importExistingCustomer	| customerIdType customerIdNumber newCustomer |		self assertRecordHasCorrectAmountOfFieldsForExistingCustomer.	customerIdType := record second.	customerIdNumber := record third.	newCustomer := customerSystem		customerIdentifiedAs: customerIdType		numbered: customerIdNumber		ifNone: [ self signalCustomerDoesNotExistError ].			newSupplier addCustomer: newCustomer.! !!SupplierImporter methodsFor: 'importing' stamp: 'AD 6/28/2018 20:23'!isSupplierRecord	^ record first = 'S'! !!SupplierImporter methodsFor: 'importing' stamp: 'AD 6/28/2018 19:34'!isAddressRecord	^ record first = 'A'! !!SupplierImporter methodsFor: 'importing' stamp: 'AgustinDelger 6/30/2018 16:17'!importRecord	self assertRecordIsNotEmpty.		self isSupplierRecord	ifTrue: [ ^ self importSupplier ].	self isNewCustomerRecord	ifTrue: [ ^ self importNewCustomer ].	self isExistingCustomerRecord	ifTrue: [ ^ self importExistingCustomer ].	self isAddressRecord	ifTrue: [ ^ self importAddress ].			self signalRecordHasInvalidType.! !!SupplierImporter methodsFor: 'importing' stamp: 'AgustinDelger 6/30/2018 17:56'!importNewCustomer			| newCustomer |		self assertRecordHasCorrectAmountOfFieldsForNewCustomer.	self assertCustomerDoesNotExistAlready.		newCustomer := Customer new.	newCustomer firstName: record second.	newCustomer lastName: record third.	newCustomer identificationType: record fourth.	newCustomer identificationNumber: record fifth.		customerSystem add: newCustomer.		newSupplier addCustomer: newCustomer.! !!SupplierImporter methodsFor: 'importing' stamp: 'AD 6/28/2018 19:34'!numberOfFieldsInRecordIs: aNumberOfFields	^ (line occurrencesOf: self fieldsDelimiter) = (aNumberOfFields - 1) and: [ record size = aNumberOfFields ]! !!SupplierImporter methodsFor: 'importing' stamp: 'AD 6/28/2018 19:42'!isNewCustomerRecord	^ record first = 'NC'! !!SupplierImporter methodsFor: 'importing' stamp: 'AD 6/30/2018 21:20'!amountOfFieldsInExistingCustomerRecord	^ 3.! !!SupplierImporter methodsFor: 'importing' stamp: 'AD 6/28/2018 19:34'!amountOfFieldsInAddressRecord		^ 6.! !!SupplierImporter methodsFor: 'importing' stamp: 'AgustinDelger 6/30/2018 18:21'!hasLineToImport		line := inputStream nextLine.	^ line notNil! !!SupplierImporter methodsFor: 'importing' stamp: 'AD 6/30/2018 20:01'!importAddress	|  newAddress |			self assertRecordHasCorrectAmountOfFieldsForAddress.	self assertASupplierHasBeenImported.		newAddress := Address new.	newAddress streetName: record second.	newAddress streetNumber: record third asInteger.	newAddress town: record fourth.	newAddress zipCode: record fifth asInteger.	newAddress := newAddress.	newAddress province: record sixth.		newSupplier addAddress: newAddress! !!SupplierImporter methodsFor: 'assertions' stamp: 'AD 6/30/2018 21:20'!assertRecordHasCorrectAmountOfFieldsForSupplier	(self numberOfFieldsInRecordIs: self amountOfFieldsInSupplierRecord)		ifFalse:[self error: self class invalidAmountOfFieldsInSupplierRecordErrorMessage].! !!SupplierImporter methodsFor: 'assertions' stamp: 'AD 6/30/2018 20:03'!assertASupplierHasBeenImported	newSupplier ifNil: [self error: self class addressRecordWithoutSupplierErrorMessage ]! !!SupplierImporter methodsFor: 'assertions' stamp: 'AD 6/30/2018 19:44'!assertCustomerDoesNotExistAlready		(customerSystem containsCustomerIdentifiedAs: record fourth numbered: record fifth) ifTrue: [self signalCustomerAlreadyExists]. ! !!SupplierImporter methodsFor: 'assertions' stamp: 'AD 6/28/2018 19:34'!signalRecordHasInvalidType	self error: self class invalidRecordTypeErrorMessage.! !!SupplierImporter methodsFor: 'assertions' stamp: 'AD 6/28/2018 19:46'!assertRecordHasCorrectAmountOfFieldsForNewCustomer	(self numberOfFieldsInRecordIs: self amountOfFieldsInNewCustomerRecord)		ifFalse:[self error: self class invalidAmountOfFieldsInNewCustomerRecordErrorMessage].! !!SupplierImporter methodsFor: 'assertions' stamp: 'AD 6/28/2018 19:34'!assertRecordIsNotEmpty	record isEmpty ifTrue:[self error: self class emptyRecordErrorMessage].! !!SupplierImporter methodsFor: 'assertions' stamp: 'AD 6/28/2018 19:34'!assertRecordHasCorrectAmountOfFieldsForAddress	(self numberOfFieldsInRecordIs: self amountOfFieldsInAddressRecord)		ifFalse:[self error: self class invalidAmountOfFieldsInAddressRecordErrorMessage].! !!SupplierImporter methodsFor: 'assertions' stamp: 'AD 6/30/2018 21:21'!assertRecordHasCorrectAmountOfFieldsForExistingCustomer	(self numberOfFieldsInRecordIs: self amountOfFieldsInExistingCustomerRecord)		ifFalse:[self error: self class invalidAmountOfFieldsInExistingCustomerRecordErrorMessage].! !!SupplierImporter methodsFor: 'initialization' stamp: 'AD 6/28/2018 19:56'!initializeFrom: anInputStream on: aSupplierSystem withCustomersIn: aCustomerSystem	inputStream := anInputStream.	supplierSystem := aSupplierSystem.	customerSystem := aCustomerSystem.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SupplierImporter class	instanceVariableNames: ''!!SupplierImporter class methodsFor: 'error messages' stamp: 'AgustinDelger 6/30/2018 18:03'!customerAlreadyExistsErrorMessage		^ 'Customer already exists.'! !!SupplierImporter class methodsFor: 'error messages' stamp: 'AD 6/30/2018 21:20'!invalidAmountOfFieldsInExistingCustomerRecordErrorMessage	^ 'Invalid amount of fields in existent customer record'! !!SupplierImporter class methodsFor: 'error messages' stamp: 'AgustinDelger 6/30/2018 16:45'!customerDoesNotExistErrorMessage		^ 'Existing customer could not be found'! !!SupplierImporter class methodsFor: 'error messages' stamp: 'AD 6/28/2018 19:34'!invalidRecordTypeErrorMessage^ 'Invalid record type'! !!SupplierImporter class methodsFor: 'error messages' stamp: 'AD 6/28/2018 19:46'!invalidAmountOfFieldsInNewCustomerRecordErrorMessage	^ 'Invalid amount of fields in new customer record'! !!SupplierImporter class methodsFor: 'error messages' stamp: 'AD 6/28/2018 19:34'!emptyRecordErrorMessage		^ 'Can not import an empty record'! !!SupplierImporter class methodsFor: 'error messages' stamp: 'AD 6/28/2018 19:34'!invalidAmountOfFieldsInAddressRecordErrorMessage	^ 'Invalid amount of fields in address record'! !!SupplierImporter class methodsFor: 'error messages' stamp: 'AD 6/28/2018 19:45'!addressRecordWithoutSupplierErrorMessage		^ 'An address record must be preceded by a supplier record.'! !!SupplierImporter class methodsFor: 'error messages' stamp: 'AD 6/30/2018 20:21'!invalidAmountOfFieldsInSupplierRecordErrorMessage	^ 'Invalid amount of fields in supplier record'! !!SupplierImporter class methodsFor: 'instance creation' stamp: 'AD 6/28/2018 19:55'!from: inputStream on: aSupplierSystem withCustomersIn: aCustomerSystem 	^ self new initializeFrom: inputStream on: aSupplierSystem withCustomersIn: aCustomerSystem.! !Object subclass: #SupplierSystem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!SupplierSystem methodsFor: 'session operations' stamp: 'AD 6/30/2018 23:36'!start	self subclassResponsibility.! !!SupplierSystem methodsFor: 'session operations' stamp: 'AD 6/30/2018 23:36'!stop	self subclassResponsibility.! !!SupplierSystem methodsFor: 'queries' stamp: 'AD 6/30/2018 22:03'!supplierIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber
	self subclassResponsibility! !!SupplierSystem methodsFor: 'queries' stamp: 'AD 6/30/2018 22:03'!amountOfSuppliersImported
	self subclassResponsibility! !!SupplierSystem methodsFor: 'queries' stamp: 'AD 6/30/2018 22:03'!supplierIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ifNone: noneBlock
	self subclassResponsibility! !!SupplierSystem methodsFor: 'adding' stamp: 'AD 6/30/2018 22:03'!add: aSupplier
	self subclassResponsibility! !SupplierSystem subclass: #PersistentSupplierSystem	instanceVariableNames: 'session'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!PersistentSupplierSystem methodsFor: 'initialization' stamp: 'AD 6/30/2018 23:22'!initialize	session := DataBaseSession				 for:					(Array with:						self addressMapping with:						self customerMapping with: 						self supplierMapping).! !!PersistentSupplierSystem methodsFor: 'queries' stamp: 'AD 6/30/2018 23:43'!supplierIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber		^ session		select: [ :aSupplier | 			aSupplier isIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ]		ofType: Supplier.! !!PersistentSupplierSystem methodsFor: 'queries' stamp: 'AD 6/30/2018 23:51'!amountOfSuppliersImported	^ (session selectAllOfType: Supplier) size! !!PersistentSupplierSystem methodsFor: 'queries' stamp: 'AD 6/30/2018 23:34'!supplierIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ifNone: noneBlock	| supplierMatches |	supplierMatches := session		select: [ :aSupplier | 			aSupplier isIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ]		ofType: Supplier.			supplierMatches isEmpty ifTrue: [ noneBlock value ].		^ supplierMatches anyOne.! !!PersistentSupplierSystem methodsFor: 'mapping' stamp: 'AD 6/30/2018 23:23'!customerMapping	^ ClassMapping		withDefaultTableNameFor: Customer		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #firstName)				with: (EmbededMapping withDefaultFieldNameFor: #lastName)				with: (EmbededMapping withDefaultFieldNameFor: #identificationType)				with: (EmbededMapping withDefaultFieldNameFor: #identificationNumber)				with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address))! !!PersistentSupplierSystem methodsFor: 'mapping' stamp: 'AD 6/30/2018 23:23'!addressMapping	^ ClassMapping		withDefaultTableNameFor: Address		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #streetName)				with: (EmbededMapping withDefaultFieldNameFor: #streetNumber)				with: (EmbededMapping withDefaultFieldNameFor: #town)				with: (EmbededMapping withDefaultFieldNameFor: #zipCode)				with: (EmbededMapping withDefaultFieldNameFor: #province))! !!PersistentSupplierSystem methodsFor: 'mapping' stamp: 'AD 6/30/2018 23:24'!supplierMapping	^ ClassMapping		withDefaultTableNameFor: Supplier		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #fullName)				with: (EmbededMapping withDefaultFieldNameFor: #identificationType)				with: (EmbededMapping withDefaultFieldNameFor: #identificationNumber)				with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address)				with: (OneToManyMapping withDefaultFieldNameFor: #customers ofType: Customer))! !!PersistentSupplierSystem methodsFor: 'adding' stamp: 'AD 6/30/2018 23:25'!add: aSupplier	session persist: aSupplier.! !!PersistentSupplierSystem methodsFor: 'session operations' stamp: 'AD 6/30/2018 23:27'!start	session open.	session beginTransaction.! !!PersistentSupplierSystem methodsFor: 'session operations' stamp: 'AD 6/30/2018 23:27'!stop	session commit.	session close! !CustomerSystem subclass: #TransientCustomerSystem	instanceVariableNames: 'customers'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!TransientCustomerSystem methodsFor: 'initialization' stamp: 'AD 6/25/2018 22:29'!initialize	customers := OrderedCollection new.! !!TransientCustomerSystem methodsFor: 'queries' stamp: 'AD 6/25/2018 22:53'!customersIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber	^ customers select: [:aCustomer | aCustomer identificationType = anIdentifycationType								and: [ aCustomer identificationNumber = anIdentificationNumber ]].	! !!TransientCustomerSystem methodsFor: 'queries' stamp: 'AD 6/30/2018 19:42'!containsCustomerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber	self customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ifNone: [^ false].	^ true.	! !!TransientCustomerSystem methodsFor: 'queries' stamp: 'AgustinDelger 6/30/2018 17:42'!customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ifNone: noneBlock		^ customers detect: [:aCustomer | aCustomer isIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ] ifNone: [noneBlock value].	! !!TransientCustomerSystem methodsFor: 'queries' stamp: 'AD 6/25/2018 22:31'!amountOfCustomersImported	^ customers size.! !!TransientCustomerSystem methodsFor: 'session operations' stamp: 'AD 6/25/2018 22:40'!start! !!TransientCustomerSystem methodsFor: 'session operations' stamp: 'AD 6/26/2018 09:43'!stop! !!TransientCustomerSystem methodsFor: 'adding' stamp: 'AD 6/26/2018 10:38'!add: aCustomer	customers add: aCustomer.! !SupplierSystem subclass: #TransientSupplierSystem	instanceVariableNames: 'suppliers'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!TransientSupplierSystem methodsFor: 'initialization' stamp: 'AD 6/28/2018 20:03'!initialize		suppliers := OrderedCollection new.! !!TransientSupplierSystem methodsFor: 'queries' stamp: 'AD 6/28/2018 20:41'!supplierIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber	^ suppliers select: [:aSupplier | aSupplier identificationType = anIdentifycationType								and: [ aSupplier identificationNumber = anIdentificationNumber ]].! !!TransientSupplierSystem methodsFor: 'queries' stamp: 'AD 6/28/2018 20:02'!amountOfSuppliersImported	^ suppliers size.! !!TransientSupplierSystem methodsFor: 'queries' stamp: 'AgustinDelger 6/30/2018 17:41'!supplierIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ifNone: noneBlock	^ suppliers detect: [:aSupplier | aSupplier isIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ] ifNone: [noneBlock value].! !!TransientSupplierSystem methodsFor: 'adding' stamp: 'AD 6/28/2018 20:29'!add: aSupplier 		suppliers add: aSupplier! !!TransientSupplierSystem methodsFor: 'session operations' stamp: 'AD 6/30/2018 22:05'!start! !!TransientSupplierSystem methodsFor: 'session operations' stamp: 'AD 6/30/2018 23:28'!stop! !'From Pharo6.0 of 13 May 2016 [Latest update: #60528] on 1 July 2018 at 11:06:15.75228 am'!!String methodsFor: '*IS1-CustomerImport' stamp: 'HernanWilkinson 10/31/2016 23:57'!asPlural		^self last = $s 		ifTrue: [ self, 'es' ]		ifFalse: [ self, 's' ]! !'From Pharo6.0 of 13 May 2016 [Latest update: #60528] on 1 July 2018 at 11:06:15.75228 am'!!Object methodsFor: '*IS1-CustomerImport' stamp: 'HernanWilkinson 10/31/2016 19:27'!toDo: aString 	! !